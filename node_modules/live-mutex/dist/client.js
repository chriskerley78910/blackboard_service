'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const util = require("util");
const assert = require("assert");
const net = require("net");
const UUID = require("uuid");
const chalk_1 = require("chalk");
const json_parser_1 = require("./json-parser");
const shared_internal_1 = require("./shared-internal");
const debugLog = process.argv.indexOf('--lmx-debug') > 0;
exports.log = {
    info: console.log.bind(console, chalk_1.default.gray.bold('lmx info:')),
    warn: console.error.bind(console, chalk_1.default.magenta.bold('lmx warning:')),
    error: console.error.bind(console, chalk_1.default.red.bold('lmx error:')),
    debug: function (...args) {
        if (debugLog) {
            let newTime = Date.now();
            let elapsed = newTime - shared_internal_1.forDebugging.previousTime;
            shared_internal_1.forDebugging.previousTime = newTime;
            console.log(chalk_1.default.yellow.bold('[lmx client debugging]'), 'elapsed millis:', `(${elapsed})`, ...args);
        }
    }
};
const we_are_debugging_1 = require("./we-are-debugging");
const events_1 = require("events");
const path = require("path");
const shared_internal_2 = require("./shared-internal");
const exceptions_1 = require("./exceptions");
if (we_are_debugging_1.weAreDebugging) {
    exports.log.debug('Live-Mutex client is in debug mode. Timeouts are turned off.');
}
exports.validConstructorOptions = {
    key: 'string',
    listener: 'Function',
    host: 'string',
    port: 'integer',
    ttl: 'integer in millis',
    unlockRequestTimeout: 'integer in millis',
    lockRequestTimeout: 'integer in millis',
    lockRetryMax: 'integer',
    keepLocksAfterDeath: 'boolean',
    keepLocksOnExit: 'boolean',
    noDelay: 'boolean',
    udsPath: 'string (absolute file path)'
};
exports.validLockOptions = {
    force: 'boolean',
    maxRetries: 'integer',
    maxRetry: 'integer',
    ttl: 'integer in millis',
    lockRequestTimeout: 'integer in millis',
    keepLocksAfterDeath: 'boolean',
    keepLocksOnExit: 'boolean'
};
exports.validUnlockOptions = {
    force: 'boolean',
    unlockRequestTimeout: 'integer',
    keepLocksAfterDeath: 'boolean'
};
class Client {
    constructor(o, cb) {
        this.keepLocksAfterDeath = false;
        this.keepLocksOnExit = false;
        this.emitter = new events_1.EventEmitter();
        this.noDelay = true;
        this.socketFile = '';
        this.readerCounts = {};
        this.writeKeys = {};
        this.isOpen = false;
        const opts = this.opts = o || {};
        assert(typeof opts === 'object', 'Bad arguments to live-mutex client constructor - options must be an object.');
        if (cb) {
            assert(typeof cb === 'function', 'optional second argument to Live-Mutex Client constructor must be a function.');
            if (process.domain) {
                cb = process.domain.bind(cb);
            }
        }
        Object.keys(opts).forEach(function (key) {
            if (!exports.validConstructorOptions[key]) {
                throw new Error('An option passed to Live-Mutex Client constructor is ' +
                    `not a recognized option => "${key}", \n valid options are: ` + util.inspect(exports.validConstructorOptions));
            }
        });
        if (opts['host']) {
            assert(typeof opts.host === 'string', ' => "host" option needs to be a string.');
        }
        if (opts['port']) {
            assert(Number.isInteger(opts.port), ' => "port" option needs to be an integer.');
            assert(opts.port > 1024 && opts.port < 49152, ' => "port" integer needs to be in range (1025-49151).');
        }
        if (opts['listener']) {
            assert(typeof opts.listener === 'function', ' => Listener should be a function.');
            assert(typeof opts.key === 'string', ' => You must pass in a key to use listener functionality.');
        }
        if (opts['lockRetryMax']) {
            assert(Number.isInteger(opts.lockRetryMax), ' => "lockRetryMax" option needs to be an integer.');
            assert(opts.lockRetryMax >= 0 && opts.lockRetryMax <= 100, ' => "lockRetryMax" integer needs to be in range (0-100).');
        }
        if (opts['retryMax']) {
            assert(Number.isInteger(opts.retryMax), ' => "retryMax" option needs to be an integer.');
            assert(opts.retryMax >= 0 && opts.retryMax <= 100, ' => "retryMax" integer needs to be in range (0-100).');
        }
        if (opts['unlockRequestTimeout']) {
            assert(Number.isInteger(opts.unlockRequestTimeout), ' => "unlockRequestTimeout" option needs to be an integer (representing milliseconds).');
            assert(opts.unlockRequestTimeout >= 20 && opts.unlockRequestTimeout <= 800000, ' => "unlockRequestTimeout" needs to be integer between 20 and 800000 millis.');
        }
        if (opts['lockRequestTimeout']) {
            assert(Number.isInteger(opts.lockRequestTimeout), ' => "lockRequestTimeout" option needs to be an integer (representing milliseconds).');
            assert(opts.lockRequestTimeout >= 20 && opts.lockRequestTimeout <= 800000, ' => "lockRequestTimeout" needs to be integer between 20 and 800000 millis.');
        }
        if (opts['ttl']) {
            assert(Number.isInteger(opts.ttl), ' => "ttl" option needs to be an integer (representing milliseconds).');
            assert(opts.ttl >= 3 && opts.ttl <= 800000, ' => "ttl" needs to be integer between 3 and 800000 millis.');
        }
        if ('keepLocksAfterDeath' in opts) {
            assert(typeof opts.keepLocksAfterDeath === 'boolean', ' => "keepLocksAfterDeath" option needs to be a boolean.');
        }
        if ('keepLocksOnExit' in opts) {
            assert(typeof opts.keepLocksOnExit === 'boolean', ' => "keepLocksOnExit" option needs to be a boolean.');
        }
        if (opts.ttl === null) {
            opts.ttl = Infinity;
        }
        if ('noDelay' in opts && opts['noDelay'] !== undefined) {
            assert(typeof opts.noDelay === 'boolean', ' => "noDelay" option needs to be an integer => ' + opts.noDelay);
            this.noDelay = opts.noDelay;
        }
        if ('udsPath' in opts && opts['udsPath'] !== undefined) {
            assert(typeof opts.udsPath === 'string', '"udsPath" option must be a string.');
            assert(path.isAbsolute(opts.udsPath), '"udsPath" option must be an absolute path.');
            this.socketFile = path.resolve(opts.udsPath);
        }
        this.keepLocksAfterDeath = Boolean(opts.keepLocksAfterDeath || opts.keepLocksOnExit);
        this.listeners = {};
        this.host = opts.host || 'localhost';
        this.port = opts.port || 6970;
        this.ttl = we_are_debugging_1.weAreDebugging ? 5000000 : (opts.ttl || 7050);
        this.unlockRequestTimeout = we_are_debugging_1.weAreDebugging ? 5000000 : (opts.unlockRequestTimeout || 8000);
        this.lockRequestTimeout = we_are_debugging_1.weAreDebugging ? 5000000 : (opts.lockRequestTimeout || 3000);
        this.lockRetryMax = opts.lockRetryMax || opts.maxRetries || opts.retryMax || 3;
        let ws = null;
        let connectPromise = null;
        const self = this;
        this.emitter.on('warning', function () {
            if (self.emitter.listenerCount('warning') < 2) {
                process.emit.call(process, 'warning', ...Array.from(arguments).map(v => (typeof v === 'string' ? v : util.inspect(v))));
                process.emit.call(process, 'warning', 'Add a "warning" event listener to the Live-Mutex client to get rid of this message.');
            }
        });
        this.write = (data, cb) => {
            if (!ws) {
                throw new Error('please call ensure()/connect() on this Live-Mutex client, before using the lock/unlock methods.');
            }
            data.max = data.max || null;
            data.pid = process.pid;
            if (data.ttl === Infinity) {
                data.ttl = null;
            }
            if ('keepLocksAfterDeath' in data) {
                data.keepLocksAfterDeath = Boolean(data.keepLocksAfterDeath);
            }
            else {
                data.keepLocksAfterDeath = this.keepLocksAfterDeath || false;
            }
            ws.write(JSON.stringify(data) + '\n', 'utf8', cb);
        };
        const onData = (data) => {
            const uuid = data.uuid;
            const _uuid = data._uuid;
            if (!(data && typeof data === 'object')) {
                return this.emitter.emit('error', 'Internal error -> data was not an object.');
            }
            if (data.error) {
                this.emitter.emit('error', data.error);
            }
            if (data.warning) {
                this.emitter.emit('warning', data.warning);
            }
            if (!uuid) {
                return this.emitter.emit('warning', 'Potential Live-Mutex implementation error => message did not contain uuid =>' + util.inspect(data));
            }
            if (self.giveups[uuid]) {
                delete self.giveups[uuid];
                return;
            }
            const fn = self.resolutions[uuid];
            const to = self.timeouts[uuid];
            delete self.timeouts[uuid];
            if (fn && to) {
                this.emitter.emit('warning', 'Function and timeout both exist => Live-Mutex implementation error.');
            }
            if (to) {
                this.emitter.emit('warning', 'Client side lock/unlock request timed-out.');
                if (data.acquired === true && data.type === 'lock') {
                    self.write({ uuid: uuid, _uuid, key: data.key, type: 'lock-received-rejected' });
                }
                return;
            }
            if (fn) {
                fn.call(this, data.error, data);
                return;
            }
            this.emitter.emit('warning', 'Live-mutex implementation warning, ' +
                'no fn with that uuid in the resolutions hash => ' + util.inspect(data, { breakLength: Infinity }));
            if (data.acquired === true && data.type === 'lock') {
                this.emitter.emit('warning', `Rejecting lock acquisition for key => "${data.key}".`);
                self.write({
                    uuid: uuid,
                    key: data.key,
                    type: 'lock-received-rejected'
                });
            }
        };
        this.ensure = this.connect = (cb) => {
            if (cb && typeof cb !== 'function') {
                throw new Error('optional argument to ensure/connect must be a function.');
            }
            if (connectPromise && ws.writable && self.isOpen) {
                return connectPromise.then((val) => {
                    cb && cb.call(self, null, val);
                    return val;
                }, function (err) {
                    cb && cb.call(self, err);
                    return Promise.reject(err);
                });
            }
            if (ws) {
                ws.removeAllListeners();
                ws.destroy((err) => (err && exports.log.error(err.message || err)));
            }
            return connectPromise = new Promise((resolve, reject) => {
                let onFirstErr = (e) => {
                    let err = '[lmx] client error => ' + (e && e.message || e);
                    this.emitter.emit('warning', err);
                    reject(err);
                };
                let to = setTimeout(function () {
                    reject('[lmx] err: client connection timeout after 3000ms.');
                }, 3000);
                let cnkt = self.socketFile ? [self.socketFile] : [self.port, self.host];
                ws = net.createConnection(...cnkt, () => {
                    self.isOpen = true;
                    clearTimeout(to);
                    ws.removeListener('error', onFirstErr);
                    resolve(this);
                });
                if (self.noDelay) {
                    ws.setNoDelay(true);
                }
                ws.setEncoding('utf8')
                    .once('end', () => {
                    this.emitter.emit('warning', '[lmx] => client stream "end" event occurred.');
                })
                    .once('error', onFirstErr)
                    .once('close', () => {
                    self.isOpen = false;
                })
                    .on('error', (e) => {
                    self.isOpen = false;
                    this.emitter.emit('warning', '[lmx] client error => ' + e.message || util.inspect(e));
                })
                    .pipe(json_parser_1.createParser())
                    .on('data', onData)
                    .once('error', function (e) {
                    self.write({ error: String(e && e.stack || e) }, function () {
                        ws.end();
                    });
                });
            })
                .then(val => {
                cb && cb.call(self, null, val);
                return val;
            }, err => {
                cb && cb.call(self, err);
                return Promise.reject(err);
            });
        };
        process.once('exit', () => {
            ws && ws.end();
        });
        this.close = () => {
            return ws && ws.end();
        };
        this.bookkeeping = {};
        this.timeouts = {};
        this.resolutions = {};
        this.giveups = {};
        this.timers = {};
        cb && this.connect(cb);
    }
    ;
    static create(opts) {
        return new Client(opts);
    }
    requestLockInfo(key, opts, cb) {
        assert.equal(typeof key, 'string', 'Key passed to lmx#lock needs to be a string.');
        if (typeof opts === 'function') {
            cb = opts;
            opts = {};
        }
        opts = opts || {};
        const uuid = opts._uuid || UUID.v4();
        this.resolutions[uuid] = (err, data) => {
            clearTimeout(this.timers[uuid]);
            delete this.timeouts[uuid];
            if (String(key) !== String(data.key)) {
                delete this.resolutions[uuid];
                throw new Error('Live-Mutex implementation error => bad key.');
            }
            if (data.error) {
                this.emitter.emit('warning', data.error);
            }
            if ([data.acquired, data.retry].filter(i => i).length > 1) {
                throw new Error('Live-Mutex implementation error.');
            }
            if (data.lockInfo === true) {
                delete this.resolutions[uuid];
                cb(null, { data });
            }
        };
        this.write({
            uuid: uuid,
            key: key,
            type: 'lock-info-request',
        });
    }
    lockp(key, opts) {
        return new Promise((resolve, reject) => {
            this.lock(key, opts, (err, val) => {
                err ? reject(err) : resolve(val);
            });
        });
    }
    unlockp(key, opts) {
        return new Promise((resolve, reject) => {
            this.unlock(key, opts, (err, val) => {
                err ? reject(err) : resolve(val);
            });
        });
    }
    acquire(key, opts) {
        return this.lockp.apply(this, arguments);
    }
    release(key, opts) {
        return this.unlockp.apply(this, arguments);
    }
    acquireLock(key, opts) {
        return this.lockp.apply(this, arguments);
    }
    releaseLock(key, opts) {
        return this.unlockp.apply(this, arguments);
    }
    run(fn) {
        return new Promise((resolve, reject) => {
            fn((err, val) => {
                err ? reject(err) : resolve(val);
            });
        });
    }
    runUnlock(fn) {
        return this.run.apply(this, arguments);
    }
    execUnlock(fn) {
        return this.run.apply(this, arguments);
    }
    cleanUp(uuid) {
        clearTimeout(this.timers[uuid]);
        delete this.timers[uuid];
        delete this.timeouts[uuid];
        delete this.resolutions[uuid];
    }
    fireUnlockCallbackWithError(cb, err) {
        const uuid = err.id;
        const key = err.key;
        this.cleanUp(uuid);
        this.emitter.emit('warning', err.message);
        cb(err, {});
    }
    fireLockCallbackWithError(cb, err) {
        const uuid = err.id;
        const key = err.key;
        this.cleanUp(uuid);
        this.emitter.emit('warning', err.message);
        cb(err, {});
    }
    ls(opts, cb) {
        if (typeof opts === 'function') {
            cb = opts;
            opts = {};
        }
        if (typeof cb !== 'function') {
            throw new Error('Callback needs to be a function type.');
        }
        opts = opts || {};
        const id = UUID.v4();
        this.resolutions[id] = cb;
        this.write({
            keepLocksAfterDeath: opts.keepLocksAfterDeath,
            uuid: id,
            type: 'ls',
        });
    }
    parseLockOpts(key, opts, cb) {
        if (typeof opts === 'function') {
            cb = opts;
            opts = {};
        }
        else if (typeof opts === 'boolean') {
            opts = { force: opts };
        }
        else if (typeof opts === 'number') {
            opts = { ttl: opts };
        }
        assert(typeof cb === 'function', 'Please use a callback as the last argument to the lock method.');
        opts = opts || {};
        return [key, opts, cb];
    }
    parseUnlockOpts(key, opts, cb) {
        if (typeof opts === 'function') {
            cb = opts;
            opts = {};
        }
        else if (typeof opts === 'boolean') {
            opts = { force: opts };
        }
        else if (typeof opts === 'string') {
            opts = { _uuid: opts };
        }
        opts = opts || {};
        assert(typeof cb === 'function', 'Please use a callback as the last argument to the unlock method.');
        return [key, opts, cb];
    }
    lock(key, opts, cb) {
        this.bookkeeping[key] = this.bookkeeping[key] || {
            rawLockCount: 0,
            rawUnlockCount: 0,
            lockCount: 0,
            unlockCount: 0
        };
        const rawLockCount = ++this.bookkeeping[key].rawLockCount;
        const unlockCount = this.bookkeeping[key].unlockCount;
        try {
            [key, opts, cb] = this.parseLockOpts(key, opts, cb);
        }
        catch (err) {
            if (typeof cb === 'function') {
                return process.nextTick(cb, err, {});
            }
            exports.log.error('No callback was passed to accept the following error.', 'Please include a callback as the final argument to the client.lock() routine.');
            throw err;
        }
        try {
            assert.equal(typeof key, 'string', 'Key passed to live-mutex #lock needs to be a string.');
            assert(typeof cb === 'function', 'callback function must be passed to Client lock() method; use lockp() or acquire() for promise API.');
            if ('max' in opts) {
                assert(Number.isInteger(opts['max']), '"max" options property must be a positive integer.');
                assert(opts['max'] > 0, '"max" options property must be a positive integer.');
            }
            if ('semaphore' in opts) {
                assert(Number.isInteger(opts['semaphore']), '"semaphore" options property must be a positive integer.');
                assert(opts['semaphore'] > 0, '"semaphore" options property must be a positive integer.');
            }
            if ('force' in opts) {
                assert.equal(typeof opts.force, 'boolean', ' => Live-Mutex usage error => ' +
                    '"force" option must be a boolean value. Coerce it on your side, for safety.');
            }
            if ('retry' in opts) {
                assert.equal(typeof opts.force, 'boolean', ' => Live-Mutex usage error => ' +
                    '"retry" option must be a boolean value. Coerce it on your side, for safety.');
                opts.__maxRetries = 0;
            }
            if ('maxRetries' in opts) {
                assert(Number.isInteger(opts.maxRetries), '"maxRetries" option must be an integer.');
                assert(opts.maxRetries >= 0 && opts.maxRetries <= 20, '"maxRetries" option must be an integer between 0 and 20 inclusive.');
                if ('__maxRetries' in opts) {
                    assert.strictEqual(opts.__maxRetries, opts.maxRetries, 'maxRetries values do not match.');
                }
                opts.__maxRetries = opts.maxRetries;
            }
            if ('maxRetry' in opts) {
                assert(Number.isInteger(opts.maxRetry), '"maxRetry" option must be an integer.');
                assert(opts.maxRetry >= 0 && opts.maxRetry <= 20, '"maxRetry" option must be an integer between 0 and 20 inclusive.');
                if ('__maxRetries' in opts) {
                    assert.strictEqual(opts.__maxRetries, opts.maxRetry, 'maxRetries values do not match.');
                }
                opts.__maxRetries = opts.maxRetry;
            }
            if ('retryMax' in opts) {
                assert(Number.isInteger(opts.retryMax), '"retryMax" option must be an integer.');
                assert(opts.retryMax >= 0 && opts.retryMax <= 20, '"retryMax" option must be an integer between 0 and 20 inclusive.');
                if ('__maxRetries' in opts) {
                    assert.strictEqual(opts.__maxRetries, opts.retryMax, 'maxRetries values do not match.');
                }
                opts.__maxRetries = opts.retryMax;
            }
            if (!('__maxRetries' in opts)) {
                opts.__maxRetries = this.lockRetryMax;
            }
            assert(Number.isInteger(opts.__maxRetries), '__maxRetries value must be an integer.');
            if (opts['ttl']) {
                assert(Number.isInteger(opts.ttl), ' => Live-Mutex usage error => Please pass an integer representing milliseconds as the value for "ttl".');
                assert(opts.ttl >= 3 && opts.ttl <= 800000, ' => Live-Mutex usage error => "ttl" for a lock needs to be integer between 3 and 800000 millis.');
            }
            if (opts['ttl'] === null) {
                opts['ttl'] = Infinity;
            }
            if (opts['lockRequestTimeout']) {
                assert(Number.isInteger(opts.lockRequestTimeout), ' => Please pass an integer representing milliseconds as the value for "ttl".');
                assert(opts.lockRequestTimeout >= 20 && opts.lockRequestTimeout <= 800000, ' => "ttl" for a lock needs to be integer between 3 and 800000 millis.');
            }
            opts.__retryCount = opts.__retryCount || 0;
            if (opts.__retryCount > 0) {
                assert(opts._uuid, 'Live-Mutex internal error: no _uuid past to retry call.');
            }
        }
        catch (err) {
            if (typeof cb === 'function') {
                return process.nextTick(cb, err, {});
            }
            exports.log.error('No callback was passed to accept the following error.', 'Please include a callback as the final argument to the client.lock() routine.');
            throw err;
        }
        if (process.domain) {
            cb = process.domain.bind(cb);
        }
        this.lockInternal(key, opts, cb);
    }
    on() {
        exports.log.warn('warning:', 'use c.emitter.on() instead of c.on()');
        return this.emitter.on.apply(this.emitter, arguments);
    }
    once() {
        exports.log.warn('warning:', 'use c.emitter.once() instead of c.once()');
        return this.emitter.once.apply(this.emitter, arguments);
    }
    lockInternal(key, opts, cb) {
        const uuid = opts._uuid = opts._uuid || UUID.v4();
        const ttl = opts.ttl || this.ttl;
        const lrt = opts.lockRequestTimeout || this.lockRequestTimeout;
        const maxRetries = opts.__maxRetries;
        const retryCount = opts.__retryCount;
        const forceUnlock = opts.forceUnlock === true;
        if (retryCount > maxRetries) {
            return this.fireLockCallbackWithError(cb, new exceptions_1.LMXClientLockException(key, uuid, shared_internal_2.LMXLockRequestError.MaxRetries, `Maximum retries (${maxRetries}) attempted to acquire lock for key "${key}".`));
        }
        const rwStatus = opts.rwStatus || null;
        const max = opts.max;
        let timedOut = false;
        this.timers[uuid] = setTimeout(() => {
            timedOut = true;
            delete this.timers[uuid];
            delete this.resolutions[uuid];
            const currentRetryCount = opts.__retryCount;
            const newRetryCount = ++opts.__retryCount;
            if (newRetryCount >= maxRetries) {
                this.timeouts[uuid] = true;
                this.write({ uuid, key, type: 'lock-client-timeout' });
                return this.fireLockCallbackWithError(cb, new exceptions_1.LMXClientLockException(key, uuid, shared_internal_2.LMXLockRequestError.RequestTimeoutError, `Live-Mutex client lock request timed out after ${lrt * opts.__retryCount} ms, ` +
                    `${currentRetryCount} retries attempted to acquire lock for key "${key}".`));
            }
            this.emitter.emit('warning', `retrying lock request for key '${key}', on host:port '${this.getHost()}:${this.getPort()}', ` +
                `retry attempt # ${newRetryCount}`);
            this.lockInternal(key, opts, cb);
        }, lrt);
        this.resolutions[uuid] = (err, data) => {
            if (timedOut) {
                return;
            }
            if (err) {
                return this.fireLockCallbackWithError(cb, new exceptions_1.LMXClientLockException(key, uuid, shared_internal_2.LMXLockRequestError.UnknownException, 'Unknown lmx client exception: ' + util.inspect(err)));
            }
            if (!data) {
                return this.fireLockCallbackWithError(cb, new exceptions_1.LMXClientLockException(key, uuid, shared_internal_2.LMXLockRequestError.InternalError, 'LMX inernal error: no data received from broker in client lock resolution callback.'));
            }
            if (data.uuid !== uuid) {
                return this.fireLockCallbackWithError(cb, new exceptions_1.LMXClientLockException(key, uuid, shared_internal_2.LMXLockRequestError.InternalError, `Internal Live-Mutex error, mismatch in uuids => '${data.uuid}', -> '${uuid}'.`));
            }
            if (String(key) !== String(data.key)) {
                return this.fireLockCallbackWithError(cb, new exceptions_1.LMXClientLockException(key, uuid, shared_internal_2.LMXLockRequestError.InternalError, `Live-Mutex internal error: bad key, [1] => '${key}', [2] => '${data.key}'.`));
            }
            if (data.error) {
                return this.fireLockCallbackWithError(cb, new exceptions_1.LMXClientLockException(key, uuid, shared_internal_2.LMXLockRequestError.GenericLockError, data.error));
            }
            if (data.acquired === true) {
                this.cleanUp(uuid);
                this.bookkeeping[key].lockCount++;
                this.write({ uuid, key, type: 'lock-received' });
                const boundUnlock = this.unlock.bind(this, key, { _uuid: uuid, rwStatus, force: forceUnlock });
                boundUnlock.acquired = true;
                boundUnlock.readersCount = Number.isInteger(data.readersCount) ? data.readersCount : null;
                boundUnlock.key = key;
                boundUnlock.unlock = boundUnlock.release = boundUnlock;
                boundUnlock.lockUuid = boundUnlock.id = uuid;
                return cb(null, boundUnlock);
            }
            if (data.reelection === true) {
                this.cleanUp(uuid);
                return this.lockInternal(key, opts, cb);
            }
            if (data.acquired === false) {
                if (opts.wait === false) {
                    this.giveups[uuid] = true;
                    this.fireLockCallbackWithError(cb, new exceptions_1.LMXClientLockException(key, uuid, shared_internal_2.LMXLockRequestError.WaitOptionSetToFalse, 'Could not acquire lock on first attempt, and "wait" option is false.'));
                }
                return;
            }
            this.fireLockCallbackWithError(cb, new exceptions_1.LMXClientLockException(key, uuid, shared_internal_2.LMXLockRequestError.InternalError, `Implementation error, please report, fallthrough in condition [1]`));
        };
        {
            let keepLocksAfterDeath = Boolean(opts.keepLocksAfterDeath || opts.keepLocksOnExit);
            this.write({
                keepLocksAfterDeath,
                retryCount,
                uuid: uuid,
                key: key,
                type: 'lock',
                ttl: ttl,
                rwStatus,
                max
            });
        }
    }
    noop() {
    }
    getPort() {
        return this.port;
    }
    getHost() {
        return this.host;
    }
    unlock(key, opts, cb) {
        this.bookkeeping[key] = this.bookkeeping[key] || {
            rawLockCount: 0,
            rawUnlockCount: 0,
            lockCount: 0,
            unlockCount: 0
        };
        this.bookkeeping[key].rawUnlockCount++;
        try {
            [key, opts, cb] = this.parseUnlockOpts(key, opts, cb);
        }
        catch (err) {
            if (typeof cb === 'function') {
                return process.nextTick(cb, err, {});
            }
            exports.log.error('No callback was passed to accept the following error.');
            throw err;
        }
        if (opts.id) {
            opts._uuid = opts.id;
        }
        if (cb && cb !== this.noop) {
            if (process.domain) {
                cb = process.domain.bind(cb);
            }
        }
        cb = cb || this.noop;
        try {
            assert.equal(typeof key, 'string', 'Key passed to live-mutex #unlock needs to be a string.');
            if (opts['force']) {
                assert.equal(typeof opts.force, 'boolean', ' => Live-Mutex usage error => ' +
                    '"force" option must be a boolean value. Coerce it on your side, for safety.');
            }
            if (opts['unlockRequestTimeout']) {
                assert(Number.isInteger(opts.lockRequestTimeout), ' => Please pass an integer representing milliseconds as the value for "ttl".');
                assert(opts.lockRequestTimeout >= 20 && opts.lockRequestTimeout <= 800000, ' => "ttl" for a lock needs to be integer between 3 and 800000 millis.');
            }
        }
        catch (err) {
            return process.nextTick(cb, err, {});
        }
        const uuid = UUID.v4();
        const rwStatus = opts.rwStatus || null;
        const urt = opts.unlockRequestTimeout || this.unlockRequestTimeout;
        let timedOut = false;
        this.timers[uuid] = setTimeout(() => {
            timedOut = true;
            this.timeouts[uuid] = true;
            this.fireUnlockCallbackWithError(cb, new exceptions_1.LMXClientUnlockException(key, uuid, shared_internal_2.LMXUnlockRequestError.BadOrMismatchedId, ` [lmx] Unlock request to unlock key => "${key}" timed out.`));
        }, urt);
        this.resolutions[uuid] = (err, data) => {
            delete this.timeouts[uuid];
            clearTimeout(this.timers[uuid]);
            if (timedOut) {
                return;
            }
            if (err) {
                return this.fireUnlockCallbackWithError(cb, new exceptions_1.LMXClientUnlockException(key, uuid, shared_internal_2.LMXUnlockRequestError.InternalError, 'LMX unknown/internal error: ' + util.inspect(err, { breakLength: Infinity })));
            }
            if (!data) {
                return this.fireUnlockCallbackWithError(cb, new exceptions_1.LMXClientUnlockException(key, uuid, shared_internal_2.LMXUnlockRequestError.InternalError, `Live-Mutex internal error: missing data in unlock resolution.`));
            }
            if (String(key) !== String(data.key)) {
                return this.fireUnlockCallbackWithError(cb, new exceptions_1.LMXClientUnlockException(key, uuid, shared_internal_2.LMXUnlockRequestError.InternalError, `Live-Mutex implementation error, bad key => first key: ${key}, second key: ${data.key}`));
            }
            if (data.error) {
                return this.fireUnlockCallbackWithError(cb, new exceptions_1.LMXClientUnlockException(key, uuid, shared_internal_2.LMXUnlockRequestError.GeneralUnlockError, 'LMX request error: ' + data.error));
            }
            if (data.unlocked === true) {
                this.cleanUp(uuid);
                this.bookkeeping[key].unlockCount++;
                return cb(null, { id: uuid, key, unlocked: true });
            }
            if (data.unlocked === false) {
                return this.fireUnlockCallbackWithError(cb, new exceptions_1.LMXClientUnlockException(key, uuid, shared_internal_2.LMXUnlockRequestError.GeneralUnlockError, data));
            }
            this.fireUnlockCallbackWithError(cb, new exceptions_1.LMXClientUnlockException(key, uuid, shared_internal_2.LMXUnlockRequestError.GeneralUnlockError, 'Internal error: fallthrough in unlock resolution routine.'));
        };
        let force = (opts.__retryCount > 0) || Boolean(opts.force);
        this.write({
            _uuid: opts._uuid || opts.id || opts.lockUuid,
            uuid: uuid,
            key: key,
            rwStatus,
            force: force,
            type: 'unlock'
        });
    }
}
exports.Client = Client;
exports.default = Client;
exports.LMXClient = Client;
exports.LvMtxClient = Client;
