'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const net = require("net");
const util = require("util");
const chalk_1 = require("chalk");
const json_parser_1 = require("./json-parser");
const linked_queue_1 = require("@oresoftware/linked-queue");
const isLocalDev = process.env.oresoftware_local_dev === 'yes';
const noop = function () {
};
const shared_internal_1 = require("./shared-internal");
const debugLog = process.argv.indexOf('--lmx-debug') > 0 || process.env.lmx_debug === 'yes';
exports.log = {
    info: console.log.bind(console, chalk_1.default.gray.bold('lmx broker info:')),
    error: console.error.bind(console, chalk_1.default.red.bold('lmx broker error:')),
    warn: console.error.bind(console, chalk_1.default.yellow.bold('lmx broker warning:')),
    debug: function (...args) {
        if (debugLog) {
            let newTime = Date.now();
            let elapsed = newTime - shared_internal_1.forDebugging.previousTime;
            shared_internal_1.forDebugging.previousTime = newTime;
            console.log(chalk_1.default.yellow.bold('[lmx broker debugging]'), 'elapsed millis:', `(${elapsed})`, ...args);
        }
    }
};
const we_are_debugging_1 = require("./we-are-debugging");
const events_1 = require("events");
const path = require("path");
const shared_internal_2 = require("./shared-internal");
if (we_are_debugging_1.weAreDebugging) {
    exports.log.error('broker is in debug mode. Timeouts are turned off.');
}
process.on('warning', function (e) {
    exports.log.error('warning:', e && e.message || e);
});
exports.validConstructorOptions = {
    lockExpiresAfter: 'integer in millis',
    timeoutToFindNewLockholder: 'integer in millis',
    host: 'string',
    port: 'integer',
    noDelay: 'boolean',
    udsPath: 'string',
    noListen: 'boolean'
};
class Broker {
    constructor(o, cb) {
        this.locks = new Map();
        this.emitter = new events_1.EventEmitter();
        this.noDelay = true;
        this.socketFile = '';
        this.lockCounts = 0;
        this.registeredListeners = {};
        this.isOpen = false;
        const opts = this.opts = o || {};
        assert(typeof opts === 'object', 'Options argument must be an object.');
        Object.keys(opts).forEach((k) => {
            if (!exports.validConstructorOptions[k]) {
                throw new Error('An option passed to Live-Mutex#Broker constructor ' +
                    `is not a recognized option => "${k}", valid options are: ${util.inspect(exports.validConstructorOptions)}.`);
            }
        });
        if (opts['lockExpiresAfter']) {
            assert(Number.isInteger(opts.lockExpiresAfter), ' => "expiresAfter" option needs to be an integer (milliseconds)');
            assert(opts.lockExpiresAfter > 20 && opts.lockExpiresAfter < 4000000, ' => "expiresAfter" is not in range (20 to 4000000 ms).');
        }
        if (opts['timeoutToFindNewLockholder']) {
            assert(Number.isInteger(opts.timeoutToFindNewLockholder), ' => "timeoutToFindNewLockholder" option needs to be an integer (milliseconds)');
            assert(opts.timeoutToFindNewLockholder > 20 && opts.timeoutToFindNewLockholder < 4000000, ' => "timeoutToFindNewLockholder" is not in range (20 to 4000000 ms).');
        }
        if (opts['host']) {
            assert(typeof opts.host === 'string', ' => "host" option needs to be a string.');
        }
        if (opts['port']) {
            assert(Number.isInteger(opts.port), ' => "port" option needs to be an integer => ' + opts.port);
            assert(opts.port > 1024 && opts.port < 49152, ' => "port" integer needs to be in range (1025-49151).');
        }
        if ('noDelay' in opts && opts['noDelay'] !== undefined) {
            assert(typeof opts.noDelay === 'boolean', ' => "noDelay" option needs to be an integer => ' + opts.noDelay);
            this.noDelay = opts.noDelay;
        }
        this.lockExpiresAfter = we_are_debugging_1.weAreDebugging ? 5000000 : (opts.lockExpiresAfter || 5000);
        this.timeoutToFindNewLockholder = we_are_debugging_1.weAreDebugging ? 5000000 : (opts.timeoutToFindNewLockholder || 4500);
        this.host = opts.host || '127.0.0.1';
        this.port = opts.port || 6970;
        this.noListen = opts.noListen === true;
        if ('udsPath' in opts && opts['udsPath'] !== undefined) {
            assert(typeof opts.udsPath === 'string', '"udsPath" option must be a string.');
            assert(path.isAbsolute(opts.udsPath), '"udsPath" option must be an absolute path.');
            this.socketFile = path.resolve(opts.udsPath);
        }
        const self = this;
        this.emitter.on('warning', function () {
            if (self.emitter.listenerCount('warning') < 2) {
                process.emit.call(process, 'warning', ...arguments);
                process.emit.call(process, 'warning', 'Add a "warning" event listener to the LMX broker to get rid of this message.');
            }
        });
        this.send = (ws, data, cb) => {
            if (!ws.writable) {
                this.emitter.emit('warning', 'socket is not writable [1].');
                return cb && process.nextTick(cb);
            }
            ws.write(JSON.stringify(data) + '\n', 'utf8', (err) => {
                if (err) {
                    this.emitter.emit('warning', 'socket is not writable [2].');
                    this.emitter.emit('warning', err);
                }
                cb && process.nextTick(cb);
            });
        };
        const onData = (ws, data) => {
            const key = data.key;
            if (data.ttl === null) {
                data.ttl = Infinity;
            }
            if (data.inspectCommand) {
                return self.inspect(data, ws);
            }
            if (data.type === 'ls') {
                return self.ls(data, ws);
            }
            if (data.type === 'unlock') {
                return self.unlock(data, ws);
            }
            if (data.type === 'lock') {
                return self.lock(data, ws);
            }
            if (data.type === 'increment-readers') {
                return self.incrementReaders(data, ws);
            }
            if (data.type === 'decrement-readers') {
                return self.decrementReaders(data, ws);
            }
            if (data.type === 'register-write-flag-check') {
                return self.registerWriteFlagCheck(data, ws);
            }
            if (data.type === 'register-write-flag-and-readers-check') {
                return self.registerWriteFlagAndReadersCheck(data, ws);
            }
            if (data.type === 'set-write-flag-false-and-broadcast') {
                return self.setWriteFlagToFalseAndBroadcast(data, ws);
            }
            if (data.type === 'lock-received') {
                clearTimeout(self.timeouts[data.key]);
                return delete self.timeouts[data.key];
            }
            if (data.type === 'lock-client-timeout') {
                const lck = self.locks.get(key);
                const uuid = data.uuid;
                if (!lck) {
                    this.emitter.emit('warning', `Lock for key "${key}" has probably expired.`);
                    return;
                }
                return lck.notify.remove(uuid);
            }
            if (data.type === 'lock-received-rejected') {
                const lck = self.locks.get(key);
                if (!lck) {
                    this.emitter.emit('warning', `Lock for key "${key}" has probably expired.`);
                    return;
                }
                self.rejected[data.uuid] = true;
                return self.ensureNewLockHolder(lck, data);
            }
            if (data.type === 'lock-info-request') {
                return self.retrieveLockInfo(data, ws);
            }
            this.emitter.emit('warning', `implementation error, bad data sent to broker => ${util.inspect(data)}`);
            self.send(ws, {
                key: data.key,
                uuid: data.uuid,
                error: 'Malformed data sent to Live-Mutex broker.'
            });
        };
        const connectedClients = new Map();
        const wss = this.wss = net.createServer((ws) => {
            connectedClients.set(ws, true);
            if (self.noDelay) {
                ws.setNoDelay(true);
            }
            if (!self.wsToKeys.get(ws)) {
                self.wsToKeys.set(ws, {});
            }
            let endWS = function () {
                try {
                    ws.end();
                }
                finally {
                }
            };
            let closeSocket = () => {
                if (ws.lmxClosed === true) {
                    return;
                }
                ws.lmxClosed = true;
                ws.removeAllListeners();
                connectedClients.delete(ws);
                const v = this.wsToKeys.get(ws);
                this.wsToKeys.delete(ws);
                const uuids = Object.keys(this.wsToUUIDs.get(ws) || {});
                this.wsToUUIDs.delete(ws);
                this.locks.forEach((v, k) => {
                    const notify = v.notify;
                    if (!v.keepLocksAfterDeath) {
                        this.unlock({ force: true, key: k, from: 'client socket closed/ended/errored' }, ws);
                    }
                });
            };
            ws.once('disconnect', function () {
                closeSocket();
            });
            ws.once('end', () => {
                closeSocket();
            });
            ws.once('error', (err) => {
                this.emitter.emit('warning', 'live-mutex client error ' + (err && err.stack || err));
                closeSocket();
            });
            ws.pipe(json_parser_1.createParser())
                .on('data', (v) => {
                onData(ws, v);
            })
                .once('error', (e) => {
                self.send(ws, {
                    error: String(e && e.stack || e)
                }, () => {
                    ws.end();
                });
            });
        });
        let callable = true;
        let sigEvent = (event) => {
            return (err) => {
                err && this.emitter.emit('warning', err);
                if (!callable) {
                    return;
                }
                callable = false;
                this.emitter.emit('warning', `"${event}" event has occurred.`);
                connectedClients.forEach(function (v, k) {
                    k.destroy();
                });
                wss.close(function () {
                    process.exit(1);
                });
            };
        };
        process.once('exit', sigEvent('exit'));
        process.once('SIGINT', sigEvent('SIGINT'));
        process.once('SIGTERM', sigEvent('SIGTERM'));
        wss.on('error', (err) => {
            this.emitter.emit('warning', 'live-mutex broker error' + (err && err.stack || err));
        });
        let brokerPromise = null;
        this.ensure = this.start = (cb) => {
            if (cb && typeof cb !== 'function') {
                throw new Error('optional argument to ensure/connect must be a function.');
            }
            if (cb && process.domain) {
                cb = process.domain.bind(cb);
            }
            if (brokerPromise) {
                return brokerPromise.then(val => {
                    cb && cb.call(self, null, val);
                    return val;
                }, (err) => {
                    cb && cb.call(self, err);
                    return Promise.reject(err);
                });
            }
            const onResolve = (val) => {
                cb && cb.call(self, null, val);
                return val;
            };
            const onRejected = (err) => {
                cb && cb.call(self, err);
                return Promise.reject(err);
            };
            if (this.noListen) {
                return brokerPromise = Promise.resolve(this)
                    .then(onResolve)
                    .catch(onRejected);
            }
            return brokerPromise = new Promise((resolve, reject) => {
                let to = setTimeout(function () {
                    reject('Live-Mutex broker error: listening action timed out.');
                }, 3000);
                wss.once('error', reject);
                let cnkt = self.socketFile ? [self.socketFile] : [self.port, self.host];
                wss.listen(...cnkt, () => {
                    self.isOpen = true;
                    clearTimeout(to);
                    wss.removeListener('error', reject);
                    resolve(self);
                });
            })
                .then(onResolve, onRejected);
        };
        this.bookkeeping = {};
        this.rejected = {};
        this.timeouts = {};
        this.wsToUUIDs = new Map();
        this.wsToKeys = new Map();
        cb && this.ensure(cb);
    }
    static create(opts) {
        return new Broker(opts);
    }
    on() {
        exports.log.warn('warning:', 'use b.emitter.on() instead of b.on()');
        return this.emitter.on.apply(this.emitter, arguments);
    }
    once() {
        exports.log.warn('warning:', 'use b.emitter.once() instead of b.once()');
        return this.emitter.once.apply(this.emitter, arguments);
    }
    close(cb) {
        this.wss.close(cb);
    }
    getPort() {
        return this.port;
    }
    getHost() {
        return this.host;
    }
    ls(data, ws) {
        return this.send(ws, { ls_result: Object.keys(this.locks), uuid: data.uuid });
    }
    broadcast(data, ws) {
        const key = data.key;
        const uuid = data.uuid;
        const v = this.registeredListeners[key] = this.registeredListeners[key] || [];
        exports.log.debug('broadcasting for key:', key);
        while (v.length > 0) {
            let p = v.pop();
            p.fn();
            this.send(p.ws, {
                key: data.key,
                uuid: p.uuid,
                type: 'broadcast-result'
            });
        }
        if (ws) {
            this.send(ws, {
                key: data.key,
                uuid: uuid,
                type: 'broadcast-success'
            });
        }
    }
    incrementReaders(data, ws) {
        const key = data.key;
        const uuid = data.uuid;
        if (!this.locks.has(key)) {
            this.locks.set(key, this.getDefaultLockObject(key, false, 1));
        }
        let lck = this.locks.get(key);
        lck.readers++;
        this.send(ws, {
            key,
            uuid,
            type: 'increment-readers-success'
        });
    }
    setWriteFlagToFalseAndBroadcast(data, ws) {
        const key = data.key;
        const uuid = data.uuid;
        if (!this.locks.has(key)) {
            this.locks.set(key, this.getDefaultLockObject(key, false, 1));
        }
        let lck = this.locks.get(key);
        exports.log.debug('setting writer flag to false.');
        lck.writerFlag = false;
        exports.log.debug('broadcasting after setting writer flag to false.');
        this.broadcast({ key }, null);
        this.send(ws, { uuid, key, type: 'write-flag-false-and-broadcast-success' });
    }
    decrementReaders(data, ws) {
        const key = data.key;
        const uuid = data.uuid;
        if (!this.locks.has(key)) {
            this.locks.set(key, this.getDefaultLockObject(key, false, 1));
        }
        let lck = this.locks.get(key);
        exports.log.debug('decrementing readers.');
        const r = lck.readers = Math.max(0, --lck.readers);
        if (r < 1) {
            exports.log.debug('broadcasting because readers are zero.');
            this.broadcast({ key }, null);
        }
        this.send(ws, {
            key,
            uuid,
            type: 'decrement-readers-success'
        });
    }
    registerWriteFlagAndReadersCheck(data, ws) {
        const key = data.key;
        const uuid = data.uuid;
        const v = this.registeredListeners[key] = this.registeredListeners[key] || [];
        if (!this.locks.has(key)) {
            this.locks.set(key, this.getDefaultLockObject(key, false, 1));
        }
        let lck = this.locks.get(key);
        const readersCount = lck && lck.readers || 0;
        const writerFlag = lck.writerFlag || false;
        if (writerFlag || readersCount > 1) {
            return v.push({
                ws, key, uuid, fn: () => {
                    exports.log.debug('delayed setting writer flag to true.');
                    lck.writerFlag = true;
                }
            });
        }
        exports.log.debug('setting writer flag to true.');
        lck.writerFlag = true;
        this.send(ws, {
            readersCount,
            writerFlag,
            key,
            uuid,
            type: 'register-write-flag-and-readers-check-success'
        });
    }
    getDefaultLockObject(key, keepLocksAfterDeath, max) {
        return {
            readers: 0,
            max: max || 1,
            lockholders: {},
            lockholdersAllReleased: {},
            keepLocksAfterDeath,
            lockholderTimeouts: {},
            key,
            notify: new linked_queue_1.LinkedQueue(),
            to: null,
            writerFlag: false,
            timestampEmptied: null
        };
    }
    registerWriteFlagCheck(data, ws) {
        const key = data.key;
        const uuid = data.uuid;
        const v = this.registeredListeners[key] = this.registeredListeners[key] || [];
        if (!this.locks.has(key)) {
            this.locks.set(key, this.getDefaultLockObject(key, false, 1));
        }
        let lck = this.locks.get(key);
        const readersCount = lck && lck.readers || 0;
        const writerFlag = lck.writerFlag || false;
        if (writerFlag) {
            return v.push({
                ws, key, uuid, fn: () => {
                    console.log('incrementing readers in delayed fashion.');
                    lck.readers++;
                }
            });
        }
        exports.log.debug('incrementing readers right after write flag check.');
        lck.readers++;
        this.send(ws, {
            writerFlag,
            readersCount,
            key,
            uuid,
            type: 'register-write-flag-success'
        });
    }
    inspect(data, ws) {
        if (typeof data.inspectCommand !== 'string') {
            return this.send(ws, { error: 'inspectCommand was not a string' });
        }
        switch (data.inspectCommand) {
            case 'lockcount':
            case 'lock-count':
            case 'lock_count':
                return this.send(ws, { inspectResult: 5 });
            case 'clientcount':
            case 'client-count':
            case 'client_count':
                return this.send(ws, { inspectResult: 17 });
            default:
                return this.send(ws, { inspectResult: 25 });
        }
    }
    ensureNewLockHolder(lck, data) {
        const locks = this.locks;
        const notifyList = lck.notify;
        if (data._uuid) {
            delete lck.lockholders[data._uuid];
        }
        lck.keepLocksAfterDeath = null;
        const key = data.key;
        clearTimeout(lck.to);
        delete lck.to;
        const self = this;
        let lqValue;
        let obj;
        while (lqValue = notifyList.shift()) {
            obj = lqValue.value;
            if (obj.ws && obj.ws.writable) {
                break;
            }
        }
        const count = Object.keys(lck.lockholders).length;
        if (!obj && count < 1) {
            lck.timestampEmptied = Date.now();
        }
        if (!obj) {
            return;
        }
        let ws = obj.ws;
        let ttl = obj.ttl;
        let uuid = obj.uuid;
        if (ttl !== Infinity) {
            ttl = we_are_debugging_1.weAreDebugging ? 50000000 : (obj.ttl || this.lockExpiresAfter);
        }
        if (!this.wsToKeys.get(ws)) {
            this.wsToKeys.set(ws, {});
        }
        this.wsToKeys.get(ws)[key] = true;
        lck.lockholders[uuid] = { pid: obj.pid, uuid, ws };
        lck.keepLocksAfterDeath = obj.keepLocksAfterDeath || false;
        let ln = lck.notify.length;
        this.send(obj.ws, {
            readersCount: lck.readers,
            key: data.key,
            uuid: obj.uuid,
            type: 'lock',
            lockRequestCount: ln,
            acquired: true
        });
        clearTimeout(this.timeouts[key]);
        if (ttl !== Infinity) {
            lck.to = setTimeout(() => {
                this.emitter.emit('warning', `Live-Mutex Broker warning, lock object timed out after ${ttl}ms for key => "${key}".`);
                lck.lockholderTimeouts[uuid] = true;
                self.unlock({ key, force: true, from: 'ttl expired for lock (3)' });
            }, ttl);
        }
        this.timeouts[key] = setTimeout(() => {
            try {
                delete this.wsToKeys.get(ws)[key];
            }
            catch (err) {
            }
            delete self.timeouts[key];
            this.emitter.emit('warning', `Re-election occurring for key: "${key}"`);
            if (locks.has(key)) {
                let lckTemp = locks.get(key);
                delete lckTemp.lockholders[uuid];
                let ln = lck.notify.length;
                let notifyList = lckTemp.notify;
                if (!self.rejected[obj.uuid]) {
                    notifyList.push(obj.uuid, obj);
                }
                notifyList.deq(5).forEach((lqv) => {
                    const obj = lqv.value;
                    self.send(obj.ws, {
                        key: data.key,
                        uuid: obj.uuid,
                        type: 'lock',
                        lockRequestCount: ln,
                        reelection: true
                    });
                });
            }
        }, self.timeoutToFindNewLockholder);
    }
    retrieveLockInfo(data, ws) {
        const key = data.key;
        const lck = this.locks.get(key);
        const uuid = data.uuid;
        const lockholderUUIDs = Object.keys(lck || {});
        const isLocked = lockholderUUIDs.length > 0;
        const lockRequestCount = lck ? lck.notify.length : null;
        if (isLocked && lockRequestCount > 0) {
            this.emitter.emit('warning', ' => Live-Mutex implementation warning, lock is unlocked but ' +
                'notify array has at least one item, for key => ' + key);
        }
        this.send(ws, {
            key, uuid, lockholderUUIDs,
            lockRequestCount,
            isLocked: Boolean(isLocked),
            lockInfo: true,
            type: 'lock-info-response'
        });
    }
    cleanUpLocks() {
        this.lockCounts = 0;
        const now = Date.now();
        this.locks.forEach((v, k) => {
            if (!v.timestampEmptied) {
                return;
            }
            if (now - v.timestampEmptied < 2000) {
                return;
            }
            const notify = v.notify.getLength();
            const count = Object.keys(v.lockholders).length;
            if (count < 1 && notify < 1) {
                exports.log.info(chalk_1.default.yellow('deleted lock object with key:'), k);
                this.locks.delete(k);
            }
        });
    }
    lock(data, ws) {
        const key = data.key;
        const keepLocksAfterDeath = Boolean(data.keepLocksAfterDeath);
        const lck = this.locks.get(key);
        if (lck) {
            lck.timestampEmptied = null;
        }
        if (++this.lockCounts > 29999) {
            this.cleanUpLocks();
        }
        const uuid = data.uuid;
        const pid = data.pid;
        const max = data.max;
        const beginRead = data.rwStatus === shared_internal_2.RWStatus.BeginRead;
        const endRead = data.rwStatus === shared_internal_2.RWStatus.EndRead;
        const count = Object.keys(lck && lck.lockholders || {}).length;
        exports.log.debug(data.rwStatus, 'is contending for lock on key:', key, 'there is/are', count, 'lockholders.');
        let ttl = data.ttl;
        if (ttl !== Infinity) {
            ttl = we_are_debugging_1.weAreDebugging ? 500000000 : (data.ttl || this.lockExpiresAfter);
        }
        if (ws && uuid) {
            if (!this.wsToUUIDs.get(ws)) {
                this.wsToUUIDs.set(ws, {});
            }
            this.wsToUUIDs.get(ws)[uuid] = true;
        }
        if (ws && !this.wsToKeys.get(ws)) {
            this.wsToKeys.set(ws, {});
        }
        const force = data.force;
        const retryCount = data.retryCount;
        this.bookkeeping[key] = this.bookkeeping[key] || {
            rawLockCount: 0,
            rawUnlockCount: 0,
            lockCount: 0,
            unlockCount: 0
        };
        this.bookkeeping[key].rawLockCount++;
        if (lck) {
            if (Number.isInteger(max)) {
                lck.max = max;
            }
            const ln = lck.notify.length;
            const count = Object.keys(lck.lockholders).length;
            if (count >= lck.max) {
                if (force) {
                    lck.notify.remove(uuid);
                    lck.notify.unshift(uuid, { ws, uuid, pid, ttl, keepLocksAfterDeath });
                }
                else {
                    const alreadyAdded = lck.notify.get(uuid);
                    if (!alreadyAdded) {
                        if (retryCount > 0) {
                            lck.notify.unshift(uuid, { ws, uuid, pid, ttl, keepLocksAfterDeath });
                        }
                        else {
                            lck.notify.push(uuid, { ws, uuid, pid, ttl, keepLocksAfterDeath });
                        }
                    }
                }
                this.send(ws, {
                    readersCount: lck.readers,
                    key: key,
                    uuid: uuid,
                    lockRequestCount: ln,
                    type: 'lock',
                    acquired: false
                });
            }
            else {
                exports.log.debug(data.rwStatus, 'has acquired lock on key:', key);
                lck.lockholders[uuid] = { ws, uuid, pid };
                clearTimeout(lck.to);
                if (beginRead) {
                    lck.readers++;
                }
                if (endRead) {
                    lck.readers = Math.max(0, --lck.readers);
                }
                if (ttl !== Infinity) {
                    lck.to = setTimeout(() => {
                        this.emitter.emit('warning', chalk_1.default.yellow.bold('Live-Mutex Broker warning, [1] lock object timed out for key => "' + key + '"'));
                        if (this.locks.has(key)) {
                            this.locks.get(key).lockholderTimeouts[uuid] = true;
                        }
                        this.unlock({ key, force: true, from: 'ttl expired for lock (1)' });
                    }, ttl);
                }
                this.wsToKeys.get(ws)[key] = true;
                this.send(ws, {
                    readersCount: lck.readers,
                    uuid: uuid,
                    key: key,
                    lockRequestCount: ln,
                    type: 'lock',
                    acquired: true
                });
            }
        }
        else {
            exports.log.debug(data.rwStatus, 'has acquired lock on key:', key);
            if (!this.wsToKeys.has(ws)) {
                this.wsToKeys.set(ws, {});
            }
            this.wsToKeys.get(ws)[key] = true;
            this.locks.set(key, {
                readers: 0,
                max: max || 1,
                lockholders: {},
                keepLocksAfterDeath,
                lockholderTimeouts: {},
                lockholdersAllReleased: {},
                key,
                notify: new linked_queue_1.LinkedQueue(),
                to: null,
                writerFlag: false,
                timestampEmptied: null
            });
            const lckTemp = this.locks.get(key);
            if (beginRead) {
                lckTemp.readers++;
            }
            if (endRead) {
                lckTemp.readers = Math.max(0, --lckTemp.readers);
            }
            lckTemp.lockholders[uuid] = { ws, uuid, pid };
            if (ttl !== Infinity) {
                lckTemp.to = setTimeout(() => {
                    this.emitter.emit('warning', 'Live-Mutex warning, [2] lock object timed out for key => "' + key + '"');
                    if (this.locks.has(key)) {
                        this.locks.get(key).lockholderTimeouts[uuid] = true;
                    }
                    this.unlock({ key, force: true, from: 'ttl expired for lock (2)' });
                }, ttl);
            }
            this.send(ws, {
                readersCount: lckTemp.readers,
                uuid: uuid,
                lockRequestCount: 0,
                key: key,
                type: 'lock',
                acquired: true
            });
        }
    }
    unlock(data, ws) {
        const key = data.key;
        const uuid = data.uuid;
        const _uuid = data._uuid;
        const force = data.force;
        const lck = this.locks.get(key);
        const keepLocksAfterDeath = Boolean(data.keepLocksAfterDeath);
        if (ws && keepLocksAfterDeath !== true) {
            try {
                delete this.wsToKeys.get(ws)[key];
            }
            catch (err) {
            }
        }
        this.bookkeeping[key] = this.bookkeeping[key] || {
            rawLockCount: 0,
            rawUnlockCount: 0,
            lockCount: 0,
            unlockCount: 0
        };
        this.bookkeeping[key].rawUnlockCount++;
        let same = null;
        if (_uuid && lck) {
            same = Boolean(lck.lockholders[_uuid]);
            exports.log.debug('same is:', same);
        }
        else if (lck) {
            exports.log.debug('no _uuid was passed to unlock');
        }
        if (lck && (same || force)) {
            const ln = lck.notify.length;
            clearTimeout(lck.to);
            delete lck.lockholderTimeouts[_uuid];
            if (force) {
                Object.keys(lck.lockholders).forEach(v => {
                    lck.lockholdersAllReleased[v] = true;
                });
                lck.lockholders = {};
            }
            if (uuid && ws) {
                this.send(ws, {
                    uuid: uuid,
                    key: key,
                    lockRequestCount: ln,
                    type: 'unlock',
                    unlocked: true
                });
            }
            this.ensureNewLockHolder(lck, data);
        }
        else if (lck) {
            const ln = lck.notify.length;
            if (lck.lockholderTimeouts[_uuid] || lck.lockholdersAllReleased[_uuid]) {
                delete lck.lockholderTimeouts[_uuid];
                delete lck.lockholdersAllReleased[_uuid];
                if (uuid && ws) {
                    this.send(ws, {
                        uuid: uuid,
                        key: key,
                        lockRequestCount: ln,
                        type: 'unlock',
                        unlocked: true
                    });
                }
                this.ensureNewLockHolder(lck, data);
            }
            else {
                if (uuid && ws) {
                    this.send(ws, {
                        uuid: uuid,
                        key: key,
                        lockRequestCount: ln,
                        type: 'unlock',
                        error: 'You need to pass the correct uuid, or use force.',
                        unlocked: false
                    });
                }
                else if (uuid) {
                    this.emitter.emit('warning', 'Implemenation warning - Missing ws (we have a uuid but no ws connection).');
                }
                else if (ws) {
                    this.emitter.emit('warning', 'Implemenation warning - Missing uuid (we have socket connection but no uuid).');
                }
            }
        }
        else {
            exports.log.debug('lock was not defined / no longer existed.');
            exports.log.debug(data.rwStatus, 'has released lock on key:', key);
            this.emitter.emit('warning', 'Live-Mutex implementation warning => no lock with key => "' + key + '"');
            if (ws && uuid) {
                this.emitter.emit('warning', `Live-Mutex warning, no lock with key => '${key}'.`);
                this.send(ws, {
                    uuid: uuid,
                    key: key,
                    lockRequestCount: 0,
                    type: 'unlock',
                    unlocked: true,
                    warning: `no lock with key => "${key}".`
                });
            }
            else if (ws) {
                this.emitter.emit('warning', chalk_1.default.red('Implemenation warning - Missing uuid (we have socket connection but no uuid).'));
            }
        }
    }
}
exports.Broker = Broker;
exports.LvMtxBroker = Broker;
exports.LMXBroker = Broker;
exports.default = Broker;
